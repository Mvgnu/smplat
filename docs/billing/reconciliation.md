# Billing Reconciliation Operations

This document outlines the workflow for ingesting Stripe statements, processing reconciliation runs, and responding to discrepancies generated by the billing worker.

## Statement Ingestion

- The `StripeStatementIngestionService` pulls Stripe balance transactions for the prior seven days, walking Stripe pagination cursors to guarantee idempotent reprocessing.
- Durable checkpoints are stored in `billing_sync_cursors`, keyed by workspace, processor, and object type. Each sync compares Stripe `updated_at` values to skip transactions that have not changed since the last pass.
- Transactions are matched to invoices through charge metadata (`invoice_id`, `workspace_id`) and stored with normalized gross, fee, and net amounts. Existing statements are updated in-place if Stripe adjusts the payload.
- Transactions without a resolvable workspace or orphaned removals are preserved in `processor_statement_staging` for manual triage instead of being silently skipped.

## Reconciliation Runs

- The `BillingLedgerReconciliationWorker` triggers statement ingestion and dispute syncs on each sweep and leverages the durable cursor table so subsequent runs continue from the last successful checkpoint per workspace.
- Each sweep opens a run with status `running`. Upon completion the worker records `completed_at`, persists a JSON note summarizing counts (persisted, updated, staged, removed, disputes, cursor), and flips the run status to `completed`. Failures are committed with `status="failed"` and error context for observability.
- Run notes now include an array of `{ workspace_id, next_cursor }` objects reflecting the cursor values returned by each ingestion call. The dashboard surfaces this metadata alongside counts so operators can see which workspace last advanced.
- The helper `reconcile_statements` evaluates persisted statements, incrementing `matched_transactions` for invoices with successful linkage and logging discrepancies when invoices are missing.
- Stripe balance transactions are now enriched with a broader type-aware reconciliation matrix covering multi-invoice settlements, payout clawbacks, dynamic fees, cross-ledger adjustments, FX variance, dispute holds, and traditional refund/fee flows. Each classification maps to a dedicated discrepancy with operator playbook metadata.
- Decision tree summary:
  1. Resolve invoice/workspace from charge metadata or payout metadata.
  2. Map transaction type → statement type using the extended taxonomy (`charge`, `refund`, `payout_delay`, `refund_reversal`, `multi_invoice_payout`, `payout_reversal`, `dynamic_fee`, `cross_ledger_transfer`, `fx_gain/fx_loss`, `dispute_withhold`, etc.).
  3. If an invoice is missing, raise the default discrepancy (`missing_invoice`, `unapplied_refund`, `untracked_fee`, `balance_adjustment`, `cross_ledger_adjustment`, `payout_clawback`, etc.).
  4. Always attach the playbook payload so dashboards/API consumers can surface recommended actions, auto-resolve thresholds, and escalation timers.
- Sample normalized payloads:
  ```json
  {
    "transactionId": "txn_payout_delay",
    "type": "payout_delay",
    "netAmount": "125.00",
    "summary": "Payout txn_payout_delay delayed for 125.00"
  }
  ```
  ```json
  {
    "transactionId": "txn_fee_adjustment",
    "type": "fee_adjustment",
    "summary": "Fee adjustment txn_fee_adjustment requires review",
    "invoiceId": "<uuid>"
  }
  ```
  ```json
  {
    "transactionId": "txn_refund_reversal",
    "type": "refund_reversal",
    "summary": "Refund reversal txn_refund_reversal requires operator confirmation"
  }
  ```

### Classification Matrix

| Statement type | Discrepancy type | Auto-resolve threshold | Key operator actions |
| -------------- | ---------------- | ---------------------- | -------------------- |
| `PAYOUT_DELAY` | `payout_delay` | — | Track payout ETA, escalate to Stripe if SLA breached |
| `MULTI_INVOICE_PAYOUT` | `multi_invoice_settlement` | ≤ 5.00 | Allocate payout across listed invoices, confirm totals |
| `PAYOUT_REVERSAL` | `payout_clawback` | — | Verify clawback reason, notify finance lead |
| `DYNAMIC_FEE` | `dynamic_fee_variance` | ≤ 2.50 | Review workspace fee overrides, sync application fees |
| `FEE_ADJUSTMENT` | `fee_adjustment` | ≤ 1.00 | Validate adjustment memo, update fee accrual workbook |
| `FEE` | `untracked_fee` | ≤ 1.00 | Map fee to invoice, update catalog |
| `REFUND` | `unapplied_refund` | — | Link refund to invoice, confirm customer comms |
| `REFUND_REVERSAL` | `refund_reversal` | — | Confirm reversal and downstream settlement |
| `CROSS_LEDGER_TRANSFER` | `cross_ledger_adjustment` | — | Confirm destination workspace/ledger, annotate memo |
| `BALANCE_ADJUSTMENT` | `balance_adjustment` | — | Document adjustment and reconcile timeline |
| `FX_GAIN`/`FX_LOSS` | `fx_impact` | ≤ 3.00 | Compare FX rate to contract, post gain/loss journal |
| `DISPUTE_WITHHOLD` | `dispute_hold` | — | Confirm dispute submission, coordinate support |

Playbook metadata is embedded in each discrepancy response (`playbook.recommendedActions`, `playbook.autoResolveThreshold`, `playbook.escalationAfterHours`, `playbook.notes`) and rendered in the admin dashboard for rapid execution.

## Dispute Automation

- Stripe disputes are fetched during every worker run. Each dispute is recorded as an `UNAPPLIED_REFUND` discrepancy tied to the open reconciliation run.
- Operators can track dispute identifiers, statuses, and deltas in the dashboard and via the API endpoints documented below.

## API Endpoints

- `GET /api/v1/billing/reconciliation/runs`: Lists recent reconciliation runs alongside open discrepancies.
-   The response contains a `metrics` object per run parsed from worker notes (persisted, updated, staged, removed, disputes, cursor, error) and a `failure` object whenever `status="failed"`. Failure metadata includes the serialized error string, the staged count snapshot at failure time, persisted/updated totals, and the cursor used by the worker so finance can resume from the last checkpoint. The payload also includes a `stagingBacklog` aggregate covering pending and requeued staging rows.
- `GET /api/v1/billing/reconciliation/discrepancies`: Returns discrepancies filtered by status and optional type (`?type=fee_adjustment|payout_delay|refund_reversal|multi_invoice_settlement|payout_clawback|cross_ledger_adjustment|fx_impact|dynamic_fee_variance|balance_adjustment|dispute_hold`). Responses now include a `playbook` payload with recommended actions and auto-resolution guidance.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/acknowledge`: Marks a discrepancy as acknowledged.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/resolve`: Resolves a discrepancy and records resolution notes.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/requeue`: Reopens a discrepancy for further investigation.
- `GET /api/v1/billing/reconciliation/staging`: Enumerates staged processor events awaiting manual triage with optional status filtering (`pending`, `triaged`, `resolved`, `requeued`).
- `POST /api/v1/billing/reconciliation/staging/{id}/triage`: Records triage outcomes and notes while updating staging status, automatically marking resolution timestamps when the entry is resolved.
- `POST /api/v1/billing/reconciliation/staging/{id}/requeue`: Flags a staged entry for reprocessing, increments its requeue counter, and clears prior resolution metadata.
- `GET /api/v1/billing/reconciliation/statements`: Returns discrepancies linked to processor statements for focused review.

## Operator Dashboard

- The admin surface at `/admin/billing/reconciliation` renders the reconciliation snapshot for finance.
- Summary KPIs highlight the staging backlog, open discrepancies, failure counts, and the most recent failure description sourced from the run `failure` metadata.
- The run history table exposes metrics and failure metadata for each sweep so operators can confirm persistence counts before re-running.
- The staging triage grid provides inline note capture with actions to mark entries triaged, resolved, or requeued; actions call the FastAPI endpoints through the Next.js API proxy.
- Discrepancies are filterable by status to accelerate investigation. Each row now surfaces the operator playbook (actions, thresholds, escalation clocks) so teams can resolve directly from the dashboard without consulting separate runbooks. Notes entered in the triage grid are persisted through the backend APIs.

## Failure Handling SOP

- Every worker exception sets the run status to `failed` and persists structured notes that include the error string, staged counts, and the per-workspace cursor checkpoints. The dashboard displays this context immediately.
- Finance should review the staging backlog first; if staged count spikes, triage pending entries or requeue those that are ready for another sync attempt.
- After addressing the root cause (e.g., missing metadata, processor downtime), operators can re-run the worker or resume ingestion using the cursor surfaced in the failure metadata. The worker automatically resumes from the saved cursor for each workspace; no manual override is required for standard retries.
- Document unusual incidents in the triage notes to maintain a historical record visible in the dashboard.

### Manual Cursor Recovery

- The `billing_sync_cursors` table captures `cursor_token`, `last_transaction_id`, and the last observed Stripe timestamps. Use these checkpoints when auditing ingestion progress or preparing a manual replay.
- To reset a workspace cursor, update the relevant row by setting `cursor_token`, `last_transaction_id`, `last_transaction_occurred_at`, and `last_transaction_updated_at` to `NULL`. Example:
  ```sql
  UPDATE billing_sync_cursors
     SET cursor_token = NULL,
         last_transaction_id = NULL,
         last_transaction_occurred_at = NULL,
         last_transaction_updated_at = NULL
   WHERE workspace_id = '<workspace-uuid>'
     AND processor = 'stripe'
     AND object_type = 'balance_transaction';
  ```
- After a reset, the next reconciliation run will start from the beginning of the Stripe history and repopulate the cursor fields using the latest data.

## Run Cadence & SLAs

- **Cadence:** Execute the reconciliation worker hourly in production to ensure timely detection of variances.
- **Dispute SLA:** Finance should acknowledge disputes within 24 hours and resolve within Stripe's dispute window.
- **Rollback:** To revert a faulty ingestion, delete the affected `processor_statements` rows and rerun the worker; discrepancies will be recalculated on the next sweep.

## Alerting & Monitoring

- Track `statements_ingested`, `statements_updated`, and `disputes_logged` metrics emitted by the worker to ensure ingestion health; monitor staging volume for untriaged processor events.
- Investigate spikes in `MISSING_INVOICE` discrepancies, which may indicate missing metadata from Stripe charges, and review the staging table for unmatched payouts/refunds.
- Use the dashboard reconciliation panel to review open items and confirm resolution flows.
