# Billing Reconciliation Operations

This document outlines the workflow for ingesting Stripe statements, processing reconciliation runs, and responding to discrepancies generated by the billing worker.

## Statement Ingestion

- The `StripeStatementIngestionService` pulls Stripe balance transactions for the prior seven days, walking Stripe pagination cursors to guarantee idempotent reprocessing.
- Transactions are matched to invoices through charge metadata (`invoice_id`, `workspace_id`) and stored with normalized gross, fee, and net amounts. Existing statements are updated in-place if Stripe adjusts the payload.
- Transactions without a resolvable workspace or orphaned removals are preserved in `processor_statement_staging` for manual triage instead of being silently skipped.

## Reconciliation Runs

- The `BillingLedgerReconciliationWorker` triggers statement ingestion and dispute syncs on each sweep and captures pagination cursors so subsequent runs continue from the last successful checkpoint.
- Each sweep opens a run with status `running`. Upon completion the worker records `completed_at`, persists a JSON note summarizing counts (persisted, updated, staged, removed, disputes, cursor), and flips the run status to `completed`. Failures are committed with `status="failed"` and error context for observability.
- The helper `reconcile_statements` evaluates persisted statements, incrementing `matched_transactions` for invoices with successful linkage and logging discrepancies when invoices are missing.

## Dispute Automation

- Stripe disputes are fetched during every worker run. Each dispute is recorded as an `UNAPPLIED_REFUND` discrepancy tied to the open reconciliation run.
- Operators can track dispute identifiers, statuses, and deltas in the dashboard and via the API endpoints documented below.

## API Endpoints

- `GET /api/v1/billing/reconciliation/runs`: Lists recent reconciliation runs alongside open discrepancies.
-   The response contains a `metrics` object per run parsed from worker notes (persisted, updated, staged, removed, disputes, cursor, error) and a `failure` object whenever `status="failed"`. Failure metadata includes the serialized error string, the staged count snapshot at failure time, persisted/updated totals, and the cursor used by the worker so finance can resume from the last checkpoint. The payload also includes a `stagingBacklog` aggregate covering pending and requeued staging rows.
- `GET /api/v1/billing/reconciliation/discrepancies`: Returns discrepancies filtered by status.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/acknowledge`: Marks a discrepancy as acknowledged.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/resolve`: Resolves a discrepancy and records resolution notes.
- `POST /api/v1/billing/reconciliation/discrepancies/{id}/requeue`: Reopens a discrepancy for further investigation.
- `GET /api/v1/billing/reconciliation/staging`: Enumerates staged processor events awaiting manual triage with optional status filtering (`pending`, `triaged`, `resolved`, `requeued`).
- `POST /api/v1/billing/reconciliation/staging/{id}/triage`: Records triage outcomes and notes while updating staging status, automatically marking resolution timestamps when the entry is resolved.
- `POST /api/v1/billing/reconciliation/staging/{id}/requeue`: Flags a staged entry for reprocessing, increments its requeue counter, and clears prior resolution metadata.
- `GET /api/v1/billing/reconciliation/statements`: Returns discrepancies linked to processor statements for focused review.

## Operator Dashboard

- The admin surface at `/admin/billing/reconciliation` renders the reconciliation snapshot for finance.
- Summary KPIs highlight the staging backlog, open discrepancies, failure counts, and the most recent failure description sourced from the run `failure` metadata.
- The run history table exposes metrics and failure metadata for each sweep so operators can confirm persistence counts before re-running.
- The staging triage grid provides inline note capture with actions to mark entries triaged, resolved, or requeued; actions call the FastAPI endpoints through the Next.js API proxy.
- Discrepancies are filterable by status to accelerate investigation. Notes entered in the triage grid are persisted through the backend APIs.

## Failure Handling SOP

- Every worker exception sets the run status to `failed` and persists structured notes that include the error string, staged counts, and the cursor checkpoint. The dashboard displays this context immediately.
- Finance should review the staging backlog first; if staged count spikes, triage pending entries or requeue those that are ready for another sync attempt.
- After addressing the root cause (e.g., missing metadata, processor downtime), operators can re-run the worker or resume ingestion using the cursor surfaced in the failure metadata.
- Document unusual incidents in the triage notes to maintain a historical record visible in the dashboard.

## Run Cadence & SLAs

- **Cadence:** Execute the reconciliation worker hourly in production to ensure timely detection of variances.
- **Dispute SLA:** Finance should acknowledge disputes within 24 hours and resolve within Stripe's dispute window.
- **Rollback:** To revert a faulty ingestion, delete the affected `processor_statements` rows and rerun the worker; discrepancies will be recalculated on the next sweep.

## Alerting & Monitoring

- Track `statements_ingested`, `statements_updated`, and `disputes_logged` metrics emitted by the worker to ensure ingestion health; monitor staging volume for untriaged processor events.
- Investigate spikes in `MISSING_INVOICE` discrepancies, which may indicate missing metadata from Stripe charges, and review the staging table for unmatched payouts/refunds.
- Use the dashboard reconciliation panel to review open items and confirm resolution flows.
